/*
 * DigitalFilters.h
 *
 *  Created on: May 25, 2018
 *      Author: markos
 */

#ifndef DIGITALFILTERS_H_
#define DIGITALFILTERS_H_

#include "DSP28x_Project.h" //has types
#include "IQmathLib.h"

/*
 * you can set the types here
 * (be careful of the input type)
 */
typedef _iq COEFF_TYPE; //coefficient type
typedef _iq SIGNAL_TYPE; //input signal type (after casted from ADC)
/*
 * definitions
 */
#define STAGES 4

/*
 * Direct form II Notch filter structure
 * -contains all the coefficients
 * -arbitrary order
 */


struct NotchFilter_DF2 {
    uint8_t stages;

    //Coefficient accuracy can be changed
    const COEFF_TYPE a[STAGES][3];
    const COEFF_TYPE b[STAGES][3];
    const COEFF_TYPE g[STAGES]; //GAIN
    COEFF_TYPE w[STAGES][3];    //MEMORY
};


/*
 * calculate filters response y[n] given  an input x[n]
 */
SIGNAL_TYPE stepNotch(struct NotchFilter_DF2 * f,SIGNAL_TYPE input);


/*
 * Actual filters that will auto-generated by an external script
 */
//notch filter for current 1
//static struct NotchFilter_DF2 NotchC1 = {
//    .a = {{_IQ(1.0),2,1},
//          {1,2,1},
//          {1,2,1},
//          {1,1,0}},
//    .b = {{1,-1.9453617195,0.95557787},
//          {1,-1.870498839,0.88032185},
//          {1,-1.8219779390,0.8315461419927},
//          {1,-0.902632479801,0}},
//    .g = {0.0025540396,0.002455753195,0.002392050747,
//          0.048683760099151},
//    .w={{0,0,0},
//        {0,0,0},
//        {0,0,0},
//        {0,0,0}},
//    .stages=STAGES
//};

static struct NotchFilter_DF2 NotchC1 = {
    .a = {{_IQ(1.0),_IQ(2.0),_IQ(1.0)},
          {_IQ(1.0),_IQ(2.0),_IQ(1.0)},
          {_IQ(1.0),_IQ(2.0),_IQ(1.0)},
          {_IQ(1.0),_IQ(1.0),_IQ(0.0)}},
    .b = {{_IQ(1.0),_IQ(-1.9453617190507683787359383131843),_IQ(0.95557787777316627320089992281282)},
          {_IQ(1.0),_IQ(-1.870498839086718545487997289456),_IQ(0.88032185186785560926381322133238)},
          {_IQ(1.0),_IQ(-1.8219779390044648081925515725743),_IQ(0.83154614199278054087471900857054)},
          {_IQ(1.0),_IQ(-0.90263247980169702966435352209373),_IQ(0.0)}},
    .g = {_IQ(0.0025540396805994441259413108014087),_IQ(0.0024557531952842950005722055806245),
          _IQ(0.0023920507470789578903513916685597),_IQ(0.048683760099151505984504950674818)},
    .w={{_IQ(0.0),_IQ(0.0),_IQ(0.0)},
        {_IQ(0.0),_IQ(0.0),_IQ(0.0)},
        {_IQ(0.0),_IQ(0.0),_IQ(0.0)},
        {_IQ(0.0),_IQ(0.0),_IQ(0.0)}},
    .stages=STAGES
};


/*
 * Simple moving average filter
 */
int16_t mov_avg(int16_t * x,uint8_t w,uint8_t pos);

#endif


